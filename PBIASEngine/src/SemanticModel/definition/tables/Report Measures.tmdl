table 'Report Measures'
	excludeFromModelRefresh
	lineageTag: 29e6330a-9023-428e-aacb-04c2bda03b37

	measure 'Duration (ms)' = ```
			
			SUM( 'Operation'[Duration (ms)] ) 
			```
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 4d67fbc1-f59f-43bd-9a13-78b865f8c07c

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'CPU Time (ms)' =
			
			SUM ( 'Operation'[CPUTime (ms)] )
		formatString: #,0
		isHidden
		displayFolder: CPU Time - Operation
		lineageTag: 80518690-131b-4df7-92cc-1bb8ba995a0f

	measure Operations =
			
			COUNTROWS ( 'Operation' )
		formatString: #,0
		displayFolder: Count
		lineageTag: 1c169129-4370-4b10-ab39-37bd7d37000d

	measure 'CPU Time 50th Percentile' =
			
			PERCENTILE.INC (
			    'Operation'[CPUTime (calculated)],
			    .5
			)
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: 7707ff0a-73b1-4e1d-ac1d-10231ebf478a

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'CPU Time 90th Percentile' =
			
			PERCENTILE.INC (
			    'Operation'[CPUTime (calculated)],
			    .9
			)
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: d5031911-99a9-4260-bf29-bdca7b1a28e1

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'CPU Time Std Dev' =
			
			STDEV.P('Operation'[CPUTime (calculated)])
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: 1c4063a2-f385-4d17-ab0d-aebefe16f4d9

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'CPU Time Std Dev %' =
			
			DIVIDE (
			    [CPU Time Std Dev],
			    [CPU Time Mean]
			)
		formatString: 0%;-0%;0%
		displayFolder: CPU Time - Operation
		lineageTag: 1ee3f56f-4420-4fcc-ba8d-f4a63aa35ea2

	measure 'CPU Time Mean' =
			
			AVERAGE ( 'Operation'[CPUTime (calculated)] )
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: d8bc98af-adab-4083-a2d1-4d8950f2874e

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'Avg Duration' =
			
			AVERAGE('Operation'[Duration (ms)])
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 2e5e0578-50e2-463c-a7c0-34aec55f25d0

		changedProperty = FormatString

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'Duration (ms) 50th Percentile' =
			
			PERCENTILE.INC (
			    'Operation'[Duration (ms)],
			    .5
			)
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 00042f3e-00ca-4dd0-8109-d3f4b66fa961

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'Duration (ms) 90th Percentile' =
			
			PERCENTILE.INC (
			    'Operation'[Duration (ms)],
			    .9
			)
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 6f588e63-4dde-4a78-8aab-55559e39dcb9

		annotation PBI_FormatHint = {"isDecimal":true}

	measure 'Duration Std Dev' = ```
			
			STDEV.P('Operation'[Duration (ms)]) 
			```
		formatString: #,0.0
		displayFolder: Duration - Operation
		lineageTag: e518bab6-1e90-46a9-b82b-aaafe3fac135

	measure 'Duration Std Dev %' =
			
			DIVIDE (
			    [Duration Std Dev],
			    [Avg Duration]
			)
		formatString: 0%;-0%;0%
		displayFolder: Duration - Operation
		lineageTag: 4be92f10-8651-4e4b-adb2-cf4b14a42848

	measure 'Suboperations - Refresh' =
			
			COUNTROWS ( 'Suboperation - Refresh' )
		formatString: #,0
		displayFolder: Count
		lineageTag: a4c804af-7d59-465e-abcf-06794cd50bbe

	measure Refreshes =
			
			CALCULATE (
			    [Operations],
			    'Operation'[Scenario ID] = 1
			)
			-- Refreshes
		formatString: #,0
		displayFolder: Count
		lineageTag: f6357772-910e-45f0-aa52-d36e053764b0

	measure Queries =
			
			CALCULATE (
			    [Operations],
			    Operation[Operation] = "QueryEnd"
			)
		formatString: #,0
		displayFolder: Count
		lineageTag: bc288d3a-aa01-4442-b689-26576677a73d

	measure 'CPU Time - Query' = ```
			
			//RR (20240111) - QueryEnd is a CPU is a total and Vertipaq CPU is included no need to sum both.
			VAR QueryEndSum =
			    CALCULATE (
			        SUM ( 'Operation'[CPUTime (ms)] ),
			        'Operation'[Operation] = "QueryEnd"
			    )
			RETURN QueryEndSum
			
			// For DAX QueryEnds, CPU Time is calculated by adding the CPU Time of all VertiPaqSEQueryEnd suboperations to the CPU Time of the QueryEnd operation.
			// For DirectQuery queries, CPU Time is simply the QueryEnd CPU Time.
			// VAR QueryEndSum =
			//     CALCULATE (
			//         SUM ( 'Operation'[CPUTime (ms)] ),
			//         'Operation'[Operation] = "QueryEnd"
			//     )
			// VAR isDQ =
			//     CALCULATE (
			//         COUNTROWS (
			//             VALUES ( 'Suboperation - Refresh'[Operation Detail] )
			//         ),
			//         'Suboperation - Refresh'[Operation Detail] = "VertiPaqSEQueryEnd"
			//     )
			// RETURN
			//     IF (
			//         isDQ,
			//         QueryEndSum,
			//         QueryEndSum + [CPU Time SE]
			//     )
			
			```
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: e14957a3-889c-414a-bd4b-daf331afc411

	measure 'CPU Time - Refresh' = ```
			
			// RR 20240110 - Fix, the operation CPU time (e.g. CommandEnd) already includes the CPU of suboperation events like ProgressReportEnd
			VAR OperationCPUTime =
			    CALCULATE (
			        SUM ( 'Operation'[CPUTime (ms)] ),
			        Scenario[ID] = 1
			    )
			RETURN
			    OperationCPUTime 
			// VAR OperationCPUTime =
			//     CALCULATE (
			//         SUM ( 'Operation'[CPUTime (ms)] ),
			//         Scenario[ID] = 1
			//     )
			// VAR SuboperationCPUTime =
			//     SUM ( 'Suboperation - Refresh'[CpuTimeMs] )
			// RETURN
			//     OperationCPUTime + SuboperationCPUTime
			```
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: 5cf7b60c-ef5e-4532-be08-94b464ea4057

	measure 'CPU Time SE' = ```
			
			// Storage Engine
			// https://github.com/DaxStudio/DaxStudio/blob/3cf6ef12dae03dcd06369e4248774068359fee7b/src/DaxStudio.UI/ViewModels/ServerTimesViewModel.cs#L287
			CALCULATE(
			        [CPU Time (ms) Suboperation - Query],
			        'Suboperation - Query'[Operation] IN ({"VertiPaqSEQueryEnd", "DirectQueryEnd"})
			)
			
			```
		formatString: #,0
		displayFolder: CPU Time - Suboperation
		lineageTag: a63d90c2-9bc4-4356-a2ed-740e2a3c265d

	measure 'Duration SE' =
			
			CALCULATE(
			        [Duration - Suboperation - Refresh],
			        'Suboperation - Refresh'[Operation] IN ({"VertiPaqSEQueryEnd", "DirectQueryEnd"})
			)
			//Storage Engine
			//https://github.com/DaxStudio/DaxStudio/blob/3cf6ef12dae03dcd06369e4248774068359fee7b/src/DaxStudio.UI/ViewModels/ServerTimesViewModel.cs#L287
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: fdac3ac8-a8c5-41e9-9237-acd2f8372c9a

	measure 'Query Rank by Duration 50th Percentile' =
			
			IF (
			    HASONEVALUE ( 'Operation'[TextDataHash] ),
			    RANKX (
			        ALLSELECTED ( 'Operation'[TextDataHash] ),
			        [Duration (ms) 50th Percentile],
			        ,
			        DESC
			    )
			)
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 36ca1eac-49a2-4aac-a0b3-9b0d09df57a9

	measure 'Duration FE' =
			[Duration (ms)] - [Duration SE]
			//Formula engine
			//https://github.com/DaxStudio/DaxStudio/blob/3cf6ef12dae03dcd06369e4248774068359fee7b/src/DaxStudio.UI/ViewModels/ServerTimesViewModel.cs#L287
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: dab28dc3-a087-41cb-8543-67655521d550

	measure 'Suboperations - Refresh (card)' =
			
			-- This measure is intended for card visuals only so any blanks will show a "0" instead of "(Blank)"
			VAR _return = [Suboperations - Refresh]
			RETURN
			    IF (
			        ISBLANK ( _return ),
			        0,
			        _return
			    )
		formatString: #,0
		displayFolder: Count
		lineageTag: 13aa6366-158f-4e03-a899-e2b9b13db7c1

	measure 'Refreshes (card)' =
			
			-- This measure is intended for card visuals only so any blanks will show a "0" instead of "(Blank)"
			VAR _return = [Refreshes]
			RETURN
			    IF (
			        ISBLANK ( _return ),
			        0,
			        _return
			    )
		formatString: #,0
		displayFolder: Count
		lineageTag: 37424972-f5ab-46e1-9ba5-669b14ad6385

	measure 'Queries (card)' =
			
			-- This measure is intended for card visuals only so any blanks will show a "0" instead of "(Blank)"
			VAR _return = [Queries]
			RETURN
			    IF (
			        ISBLANK ( _return ),
			        0,
			        _return
			    )
		formatString: #,0
		displayFolder: Count
		lineageTag: 8d1894e3-09bc-4bd1-9eab-10a2f6345b02

	measure 'CPU Time FE' =
			[CPU Time - Query] - [CPU Time SE]
			//Formula engine
			//https://github.com/DaxStudio/DaxStudio/blob/3cf6ef12dae03dcd06369e4248774068359fee7b/src/DaxStudio.UI/ViewModels/ServerTimesViewModel.cs#L287
		formatString: #,0
		displayFolder: CPU Time - Suboperation
		lineageTag: 2790d27c-dd1d-4389-b5c0-385d11af37c6

	measure 'Query Cache Hits' =
			
			CALCULATE (
			    [Queries],
			    'Suboperation - Query'[Operation] = "VertiPaqSEQueryCacheMatch",
			    CROSSFILTER ( Operation[Query Suboperation Key], 'Suboperation - Query'[XmlaRequestId], BOTH )
			)
		formatString: #,0
		displayFolder: Count
		lineageTag: 0baf7ae5-8872-4c81-b70b-0db6042ac414

	measure 'CPU Time (ms) Suboperation - Refresh' = ```
			
			SUM('Suboperation - Refresh'[CpuTimeMs]) 
			```
		formatString: #,0
		displayFolder: CPU Time - Suboperation
		lineageTag: 65302eb2-6e8a-42eb-8757-c7b00157389a

	measure 'Duration - Suboperation - Refresh' = ```
			
			SUM( 'Suboperation - Refresh'[Duration (ms)] ) 
			```
		formatString: #,0
		displayFolder: Duration - Suboperation
		lineageTag: f4c7e3b6-eac7-4cb7-99a4-c89a09f081bf

	measure 'Operations (card)' =
			
			-- This measure is intended for card visuals only so any blanks will show a "0" instead of "(Blank)"
			VAR _return = [Operations]
			RETURN
			    IF (
			        ISBLANK ( _return ),
			        0,
			        _return
			    )
		formatString: #,0
		displayFolder: Count
		lineageTag: bb17a1ca-b7d1-4b99-978c-6e44a3db399d

	measure 'CPUTime Max Suboperation - Refresh' =
			
			MAX('Suboperation - Refresh'[CpuTimeMs])
		formatString: #,0
		displayFolder: CPU Time - Suboperation
		lineageTag: f3b85869-14d9-44ec-bd90-8cf649124310

	measure 'CPU Time - Max' =
			
			MAX ( Operation[CPUTime (calculated)] )
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: c1f29fca-9c9a-4580-8990-54be66e43ed3

	measure 'Report DCount' =
			
			DISTINCTCOUNT ( Operation[ReportId] )
		formatString: #,0
		displayFolder: Count
		lineageTag: a8ed4df9-9696-47ca-a91f-c00e97cbc213

	measure 'User count' =
			
			DISTINCTCOUNT (Operation[Executing User] )
		formatString: #,0
		displayFolder: Count
		lineageTag: 64fe7776-96bc-4f9f-a93d-b66547228650

	measure 'Dataset Dcount' =
			
			DISTINCTCOUNT ( Operation[DatasetId] )
		formatString: #,0
		displayFolder: Count
		lineageTag: 30ade1d2-5968-4270-ae43-28611efcd955

	measure 'Query Detail.Related Queries' =
			
			"Related queries details ("
			    & FORMAT (
			        [Suboperations - Query (card)],
			        "#,##0"
			    ) & ")"
		displayFolder: Titles
		lineageTag: 02faa3f8-7aa1-4864-9a7f-8c7e23643110

	measure 'Dataset Refresh.Data Refresh Operations' =
			
			"Dataset refresh operations ("
			    & FORMAT (
			        [Refreshes (card)],
			        "#,##0"
			    ) & ")"
		displayFolder: Titles
		lineageTag: 24917862-4900-4ea0-8608-c2e4da282ec0

	measure 'Workspace DCount' =
			
			DISTINCTCOUNT ( Operation[WorkspaceId] )
		formatString: #,0
		displayFolder: Count
		lineageTag: acc18f81-093a-4b86-baf8-26f1e157a145

	measure 'Operations.Operations' =
			
			"Operations ("
			    & FORMAT (
			        [Operations (card)],
			        "#,##0"
			    ) & ")"
		displayFolder: Titles
		lineageTag: 859ef5cb-dd92-485f-8ea7-bec7dae77072

	measure 'Query History.Query Executions' =
			
			"Query executions ("
			    & FORMAT (
			        [Operations],
			        "#,##0"
			    ) & ")"
		displayFolder: Titles
		lineageTag: 73317778-9851-4232-8002-8233e5860d82

	measure 'CPU Time P50 Sparkline' = ```
			
			VAR LineColor = "#363636" // Line color
			VAR FillColor = "#ffffff" // Fill color
			VAR MaxDotColor = "#649398" // Max dot color
			VAR MinDotColor = "#D9655D" // Min dot color
			VAR FirstDotColor = "#363636" // First dot color
			VAR LastDotColor = "#363636" // Last dot color
			VAR NumOfDashes = 0 // Change this number to the number of dashes you'd like the line to be, 0 is a solid line
			VAR DataPointPoint = DISTINCTCOUNT('Calendar'[Date]) // Put "date" here, distinct count of x axis data points
			VAR StrokeWidth = // Dynamic line stroke width, decreases stroke width as data points increase
			    SWITCH( TRUE(), 
			    DataPointPoint > 24, 3, 
			    DataPointPoint > 12, 4, 
			    5)
			VAR CircleSize = // Dynamic circle size, decreases circle size as data points increase
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, 8, 
			    DataPointPoint > 12, 9, 
			    10)
			VAR ViewboxOffset = // Viewbox Offset for circle size, matches circles to keep them visible as size changes
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, -8, 
			    DataPointPoint > 12, -9, 
			    -10)
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN('Calendar'[Date])
			VAR XMaxDate = MAX('Calendar'[Date])
			// Obtains overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX( VALUES('Calendar'[Date]), CALCULATE([CPU Time 50th Percentile]))
			VAR YMaxValue = MAXX( VALUES('Calendar'[Date]), CALCULATE([CPU Time 50th Percentile]))
			// Build table of X & Y coordinates and fit to 100 x 100 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('Calendar', 'Calendar'[Date]),
			        "X",INT(100 * DIVIDE('Calendar'[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(100 * DIVIDE([CPU Time 50th Percentile] - YMinValue, YMaxValue - YMinValue)))
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", 'Calendar'[Date])
			// Create circles for the min and max data points on the line
			VAR MaxSparkYValue = MAXX(SparklineTable, 100 - [Y])
			VAR MaxSparkXValue = MAXX( FILTER(SparklineTable, [Y] = MaxSparkYValue), [X])
			VAR MinSparkYValue = MINX(SparklineTable, 100 - [Y])
			VAR MinSparkXValue = MINX( FILTER(SparklineTable, [Y] = MinSparkYValue), [X])
			// Create circles for the first and last data points on the line
			VAR FirstSparkYValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [Y])
			VAR FirstSparkXValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [X])
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [X])
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 " & ViewboxOffset & " 100 120'>" &
			    "<polyline 
			        fill='" & FillColor & "' 
			        stroke='" & LineColor & "' 
			        stroke-width='" & StrokeWidth & "' 
			        stroke-linecap='round' 
			        stroke-linejoin='round' 
			        stroke-dasharray='" & NumOfDashes & "'
			        points='" & Lines & 
			    "'/>" & 
			    //"<circle cx='"& FirstSparkXValue & "' cy='" & 100 - FirstSparkYValue & "' r='" & CircleSize & "' fill='" & FirstDotColor & "' />" & // First sparkline circle
			    //"<circle cx='"& LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='" & CircleSize & "' fill='" & LastDotColor & "' />" & // Last sparkline circle
			   // "<circle cx='"& MaxSparkXValue & "' cy='" & 100 - MaxSparkYValue & "' r='" & CircleSize & "' fill='" & MaxDotColor & "' />" & // Max sparkline circle
			    //"<circle cx='"& MinSparkXValue & "' cy='" & 100 - MinSparkYValue & "' r='" & CircleSize & "' fill='" & MinDotColor & "' />" & // Min sparkline circle
			    "</svg>"
			RETURN
			SVGImageURL --IF( HASONEVALUE('Calendar'[Date]), SVGImageURL)
			```
		displayFolder: Sparkline
		lineageTag: 1350c703-c646-46dd-83ec-daa6625ce96e
		dataCategory: ImageUrl

	measure 'Total Executions Sparkline' = ```
			
			VAR LineColor = "#363636" // Line color
			VAR FillColor = "#ffffff" // Fill color
			VAR MaxDotColor = "#649398" // Max dot color
			VAR MinDotColor = "#D9655D" // Min dot color
			VAR FirstDotColor = "#363636" // First dot color
			VAR LastDotColor = "#363636" // Last dot color
			VAR NumOfDashes = 0 // Change this number to the number of dashes you'd like the line to be, 0 is a solid line
			VAR DataPointPoint = DISTINCTCOUNT('Calendar'[Date]) // Put "date" here, distinct count of x axis data points
			VAR StrokeWidth = // Dynamic line stroke width, decreases stroke width as data points increase
			    SWITCH( TRUE(), 
			    DataPointPoint > 24, 3, 
			    DataPointPoint > 12, 4, 
			    5)
			VAR CircleSize = // Dynamic circle size, decreases circle size as data points increase
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, 8, 
			    DataPointPoint > 12, 9, 
			    10)
			VAR ViewboxOffset = // Viewbox Offset for circle size, matches circles to keep them visible as size changes
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, -8, 
			    DataPointPoint > 12, -9, 
			    -10)
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN('Calendar'[Date])
			VAR XMaxDate = MAX('Calendar'[Date])
			// Obtains overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX( VALUES('Calendar'[Date]), CALCULATE([Operations]))
			VAR YMaxValue = MAXX( VALUES('Calendar'[Date]), CALCULATE([Operations]))
			// Build table of X & Y coordinates and fit to 100 x 100 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('Calendar', 'Calendar'[Date]),
			        "X",INT(100 * DIVIDE('Calendar'[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(100 * DIVIDE([Operations] - YMinValue, YMaxValue - YMinValue)))
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", 'Calendar'[Date])
			// Create circles for the min and max data points on the line
			VAR MaxSparkYValue = MAXX(SparklineTable, 100 - [Y])
			VAR MaxSparkXValue = MAXX( FILTER(SparklineTable, [Y] = MaxSparkYValue), [X])
			VAR MinSparkYValue = MINX(SparklineTable, 100 - [Y])
			VAR MinSparkXValue = MINX( FILTER(SparklineTable, [Y] = MinSparkYValue), [X])
			// Create circles for the first and last data points on the line
			VAR FirstSparkYValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [Y])
			VAR FirstSparkXValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [X])
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [X])
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 " & ViewboxOffset & " 100 120'>" &
			    "<polyline 
			        fill='" & FillColor & "' 
			        stroke='" & LineColor & "' 
			        stroke-width='" & StrokeWidth & "' 
			        stroke-linecap='round' 
			        stroke-linejoin='round' 
			        stroke-dasharray='" & NumOfDashes & "'
			        points='" & Lines & 
			    "'/>" & 
			    //"<circle cx='"& FirstSparkXValue & "' cy='" & 100 - FirstSparkYValue & "' r='" & CircleSize & "' fill='" & FirstDotColor & "' />" & // First sparkline circle
			    //"<circle cx='"& LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='" & CircleSize & "' fill='" & LastDotColor & "' />" & // Last sparkline circle
			   // "<circle cx='"& MaxSparkXValue & "' cy='" & 100 - MaxSparkYValue & "' r='" & CircleSize & "' fill='" & MaxDotColor & "' />" & // Max sparkline circle
			    //"<circle cx='"& MinSparkXValue & "' cy='" & 100 - MinSparkYValue & "' r='" & CircleSize & "' fill='" & MinDotColor & "' />" & // Min sparkline circle
			    "</svg>"
			RETURN
			SVGImageURL --IF( HASONEVALUE('Calendar'[Date]), SVGImageURL)
			```
		displayFolder: Sparkline
		lineageTag: ef754dd8-2d68-4ba0-81e0-bea46e1809c8
		dataCategory: ImageUrl

	measure 'CPU Time P90 Sparkline' = ```
			
			VAR LineColor = "#363636" // Line color
			VAR FillColor = "#ffffff" // Fill color
			VAR MaxDotColor = "#649398" // Max dot color
			VAR MinDotColor = "#D9655D" // Min dot color
			VAR FirstDotColor = "#363636" // First dot color
			VAR LastDotColor = "#363636" // Last dot color
			VAR NumOfDashes = 0 // Change this number to the number of dashes you'd like the line to be, 0 is a solid line
			VAR DataPointPoint = DISTINCTCOUNT('Calendar'[Date]) // Put "date" here, distinct count of x axis data points
			VAR StrokeWidth = // Dynamic line stroke width, decreases stroke width as data points increase
			    SWITCH( TRUE(), 
			    DataPointPoint > 24, 3, 
			    DataPointPoint > 12, 4, 
			    5)
			VAR CircleSize = // Dynamic circle size, decreases circle size as data points increase
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, 8, 
			    DataPointPoint > 12, 9, 
			    10)
			VAR ViewboxOffset = // Viewbox Offset for circle size, matches circles to keep them visible as size changes
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, -8, 
			    DataPointPoint > 12, -9, 
			    -10)
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN('Calendar'[Date])
			VAR XMaxDate = MAX('Calendar'[Date])
			// Obtains overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX( VALUES('Calendar'[Date]), CALCULATE([CPU Time 90th Percentile]))
			VAR YMaxValue = MAXX( VALUES('Calendar'[Date]), CALCULATE([CPU Time 90th Percentile]))
			// Build table of X & Y coordinates and fit to 100 x 100 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('Calendar', 'Calendar'[Date]),
			        "X",INT(100 * DIVIDE('Calendar'[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(100 * DIVIDE([CPU Time 90th Percentile] - YMinValue, YMaxValue - YMinValue)))
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", 'Calendar'[Date])
			// Create circles for the min and max data points on the line
			VAR MaxSparkYValue = MAXX(SparklineTable, 100 - [Y])
			VAR MaxSparkXValue = MAXX( FILTER(SparklineTable, [Y] = MaxSparkYValue), [X])
			VAR MinSparkYValue = MINX(SparklineTable, 100 - [Y])
			VAR MinSparkXValue = MINX( FILTER(SparklineTable, [Y] = MinSparkYValue), [X])
			// Create circles for the first and last data points on the line
			VAR FirstSparkYValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [Y])
			VAR FirstSparkXValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [X])
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [X])
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 " & ViewboxOffset & " 100 120'>" &
			    "<polyline 
			        fill='" & FillColor & "' 
			        stroke='" & LineColor & "' 
			        stroke-width='" & StrokeWidth & "' 
			        stroke-linecap='round' 
			        stroke-linejoin='round' 
			        stroke-dasharray='" & NumOfDashes & "'
			        points='" & Lines & 
			    "'/>" & 
			    //"<circle cx='"& FirstSparkXValue & "' cy='" & 100 - FirstSparkYValue & "' r='" & CircleSize & "' fill='" & FirstDotColor & "' />" & // First sparkline circle
			    //"<circle cx='"& LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='" & CircleSize & "' fill='" & LastDotColor & "' />" & // Last sparkline circle
			   // "<circle cx='"& MaxSparkXValue & "' cy='" & 100 - MaxSparkYValue & "' r='" & CircleSize & "' fill='" & MaxDotColor & "' />" & // Max sparkline circle
			    //"<circle cx='"& MinSparkXValue & "' cy='" & 100 - MinSparkYValue & "' r='" & CircleSize & "' fill='" & MinDotColor & "' />" & // Min sparkline circle
			    "</svg>"
			RETURN
			SVGImageURL --IF( HASONEVALUE('Calendar'[Date]), SVGImageURL)
			```
		displayFolder: Sparkline
		lineageTag: 84b683fa-7809-429d-8d60-be9c60278213
		dataCategory: ImageUrl

	measure 'Duration P50 Sparkline' = ```
			
			VAR LineColor = "#363636" // Line color
			VAR FillColor = "#ffffff" // Fill color
			VAR MaxDotColor = "#649398" // Max dot color
			VAR MinDotColor = "#D9655D" // Min dot color
			VAR FirstDotColor = "#363636" // First dot color
			VAR LastDotColor = "#363636" // Last dot color
			VAR NumOfDashes = 0 // Change this number to the number of dashes you'd like the line to be, 0 is a solid line
			VAR DataPointPoint = DISTINCTCOUNT('Calendar'[Date]) // Put "date" here, distinct count of x axis data points
			VAR StrokeWidth = // Dynamic line stroke width, decreases stroke width as data points increase
			    SWITCH( TRUE(), 
			    DataPointPoint > 24, 3, 
			    DataPointPoint > 12, 4, 
			    5)
			VAR CircleSize = // Dynamic circle size, decreases circle size as data points increase
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, 8, 
			    DataPointPoint > 12, 9, 
			    10)
			VAR ViewboxOffset = // Viewbox Offset for circle size, matches circles to keep them visible as size changes
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, -8, 
			    DataPointPoint > 12, -9, 
			    -10)
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN('Calendar'[Date])
			VAR XMaxDate = MAX('Calendar'[Date])
			// Obtains overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX( VALUES('Calendar'[Date]), CALCULATE([Duration (ms) 50th Percentile]))
			VAR YMaxValue = MAXX( VALUES('Calendar'[Date]), CALCULATE([Duration (ms) 50th Percentile]))
			// Build table of X & Y coordinates and fit to 100 x 100 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('Calendar', 'Calendar'[Date]),
			        "X",INT(100 * DIVIDE('Calendar'[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(100 * DIVIDE([Duration (ms) 50th Percentile] - YMinValue, YMaxValue - YMinValue)))
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", 'Calendar'[Date])
			// Create circles for the min and max data points on the line
			VAR MaxSparkYValue = MAXX(SparklineTable, 100 - [Y])
			VAR MaxSparkXValue = MAXX( FILTER(SparklineTable, [Y] = MaxSparkYValue), [X])
			VAR MinSparkYValue = MINX(SparklineTable, 100 - [Y])
			VAR MinSparkXValue = MINX( FILTER(SparklineTable, [Y] = MinSparkYValue), [X])
			// Create circles for the first and last data points on the line
			VAR FirstSparkYValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [Y])
			VAR FirstSparkXValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [X])
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [X])
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 " & ViewboxOffset & " 100 120'>" &
			    "<polyline 
			        fill='" & FillColor & "' 
			        stroke='" & LineColor & "' 
			        stroke-width='" & StrokeWidth & "' 
			        stroke-linecap='round' 
			        stroke-linejoin='round' 
			        stroke-dasharray='" & NumOfDashes & "'
			        points='" & Lines & 
			    "'/>" & 
			    //"<circle cx='"& FirstSparkXValue & "' cy='" & 100 - FirstSparkYValue & "' r='" & CircleSize & "' fill='" & FirstDotColor & "' />" & // First sparkline circle
			    //"<circle cx='"& LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='" & CircleSize & "' fill='" & LastDotColor & "' />" & // Last sparkline circle
			   // "<circle cx='"& MaxSparkXValue & "' cy='" & 100 - MaxSparkYValue & "' r='" & CircleSize & "' fill='" & MaxDotColor & "' />" & // Max sparkline circle
			    //"<circle cx='"& MinSparkXValue & "' cy='" & 100 - MinSparkYValue & "' r='" & CircleSize & "' fill='" & MinDotColor & "' />" & // Min sparkline circle
			    "</svg>"
			RETURN
			SVGImageURL --IF( HASONEVALUE('Calendar'[Date]), SVGImageURL)
			```
		displayFolder: Sparkline
		lineageTag: 744df686-24fc-4b29-b588-9acb915dabe8
		dataCategory: ImageUrl

	measure 'Duration P90 Sparkline' = ```
			
			VAR LineColor = "#363636" // Line color
			VAR FillColor = "#ffffff" // Fill color
			VAR MaxDotColor = "#649398" // Max dot color
			VAR MinDotColor = "#D9655D" // Min dot color
			VAR FirstDotColor = "#363636" // First dot color
			VAR LastDotColor = "#363636" // Last dot color
			VAR NumOfDashes = 0 // Change this number to the number of dashes you'd like the line to be, 0 is a solid line
			VAR DataPointPoint = DISTINCTCOUNT('Calendar'[Date]) // Put "date" here, distinct count of x axis data points
			VAR StrokeWidth = // Dynamic line stroke width, decreases stroke width as data points increase
			    SWITCH( TRUE(), 
			    DataPointPoint > 24, 3, 
			    DataPointPoint > 12, 4, 
			    5)
			VAR CircleSize = // Dynamic circle size, decreases circle size as data points increase
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, 8, 
			    DataPointPoint > 12, 9, 
			    10)
			VAR ViewboxOffset = // Viewbox Offset for circle size, matches circles to keep them visible as size changes
			    SWITCH(TRUE(), 
			    DataPointPoint > 24, -8, 
			    DataPointPoint > 12, -9, 
			    -10)
			// "Date" field used in this example along the X axis
			VAR XMinDate = MIN('Calendar'[Date])
			VAR XMaxDate = MAX('Calendar'[Date])
			// Obtains overall min and overall max measure values when evaluated for each date
			VAR YMinValue = MINX( VALUES('Calendar'[Date]), CALCULATE([Duration (ms) 90th Percentile]))
			VAR YMaxValue = MAXX( VALUES('Calendar'[Date]), CALCULATE([Duration (ms) 90th Percentile]))
			// Build table of X & Y coordinates and fit to 100 x 100 viewbox
			VAR SparklineTable = ADDCOLUMNS(
			    SUMMARIZE('Calendar', 'Calendar'[Date]),
			        "X",INT(100 * DIVIDE('Calendar'[Date] - XMinDate, XMaxDate - XMinDate)),
			        "Y",INT(100 * DIVIDE([Duration (ms) 90th Percentile] - YMinValue, YMaxValue - YMinValue)))
			// Concatenate X & Y coordinates to build the sparkline
			VAR Lines = CONCATENATEX(SparklineTable, [X] & "," & 100 - [Y], " ", 'Calendar'[Date])
			// Create circles for the min and max data points on the line
			VAR MaxSparkYValue = MAXX(SparklineTable, 100 - [Y])
			VAR MaxSparkXValue = MAXX( FILTER(SparklineTable, [Y] = MaxSparkYValue), [X])
			VAR MinSparkYValue = MINX(SparklineTable, 100 - [Y])
			VAR MinSparkXValue = MINX( FILTER(SparklineTable, [Y] = MinSparkYValue), [X])
			// Create circles for the first and last data points on the line
			VAR FirstSparkYValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [Y])
			VAR FirstSparkXValue = MINX( FILTER(SparklineTable, 'Calendar'[Date] = XMinDate), [X])
			VAR LastSparkYValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [Y])
			VAR LastSparkXValue = MAXX( FILTER(SparklineTable, 'Calendar'[Date] = XMaxDate), [X])
			// Add to SVG, and verify Data Category is set to Image URL for this measure
			VAR SVGImageURL = 
			    "data:image/svg+xml;utf8," & 
			    "<svg xmlns='http://www.w3.org/2000/svg' x='0px' y='0px' viewBox='0 " & ViewboxOffset & " 100 120'>" &
			    "<polyline 
			        fill='" & FillColor & "' 
			        stroke='" & LineColor & "' 
			        stroke-width='" & StrokeWidth & "' 
			        stroke-linecap='round' 
			        stroke-linejoin='round' 
			        stroke-dasharray='" & NumOfDashes & "'
			        points='" & Lines & 
			    "'/>" & 
			    //"<circle cx='"& FirstSparkXValue & "' cy='" & 100 - FirstSparkYValue & "' r='" & CircleSize & "' fill='" & FirstDotColor & "' />" & // First sparkline circle
			    //"<circle cx='"& LastSparkXValue & "' cy='" & 100 - LastSparkYValue & "' r='" & CircleSize & "' fill='" & LastDotColor & "' />" & // Last sparkline circle
			   // "<circle cx='"& MaxSparkXValue & "' cy='" & 100 - MaxSparkYValue & "' r='" & CircleSize & "' fill='" & MaxDotColor & "' />" & // Max sparkline circle
			    //"<circle cx='"& MinSparkXValue & "' cy='" & 100 - MinSparkYValue & "' r='" & CircleSize & "' fill='" & MinDotColor & "' />" & // Min sparkline circle
			    "</svg>"
			RETURN
			SVGImageURL --IF( HASONEVALUE('Calendar'[Date]), SVGImageURL)
			```
		displayFolder: Sparkline
		lineageTag: 21727d4e-4a09-41b3-b828-5245ba49cd1a
		dataCategory: ImageUrl

	measure 'CPU Time (ms) Total' =
			
			SWITCH( MIN(Scenario[ID] ),
			1, [CPU Time - Refresh],
			2, [CPU Time - Query],
			[CPU Time (ms)]
			 ) //
		formatString: #,0
		displayFolder: CPU Time - Operation
		lineageTag: d4e265ac-9a55-4695-b3af-3b2797d0c775

	measure 'Duration - Refresh' =
			
			VAR OperationDuration =
			    CALCULATE (
			        [Duration (ms)],
			        Scenario[ID] = 1
			    )
			RETURN
			    OperationDuration
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 099f7a96-810e-46d6-b283-8f824fed0d87

	measure 'Dataset Refresh Detail.Refresh Information' =
			
			"Dataset refresh rootActivityId: "
			    & MIN ( Operation[XmlaRequestId] )
		displayFolder: Titles
		lineageTag: dd703faf-9d0d-461e-a730-6524945b338e

	measure 'Dataset Refresh Detail.CPU Time' =
			
			"CPU time: "
			    & FORMAT (
			        [CPU Time (ms) Total],
			        "#,###"
			    ) & " ms"
		displayFolder: Titles
		lineageTag: 77b21591-e9c4-492a-88c5-33bca758a606

	measure 'Dataset Refresh Detail.Duration' =
			
			VAR _duration = [Duration (ms)]
			RETURN
			    IF (
			        _duration > 0,
			        "Duration: "
			            & FORMAT (
			                [Duration (ms)],
			                "#,###"
			            ) & " ms",
			        "Duration: 0 ms"
			    )
		displayFolder: Titles
		lineageTag: d1640120-9548-4fab-857e-c547a1826d22

	measure 'Dataset Refresh.Data Refresh Suboperations' =
			
			"Dataset refresh suboperations ("
			    & FORMAT (
			        [Suboperations - Refresh (card)],
			        "#,##0"
			    ) & ")"
		displayFolder: Titles
		lineageTag: 5b8def65-399c-49d4-ab52-f12d44412696

	measure 'Capacity DCount' =
			
			DISTINCTCOUNT ( Operation[PremiumCapacityId] )
		formatString: #,0
		displayFolder: Count
		lineageTag: 728cc434-3367-4fb6-b035-b3f9ed00ae3d

	measure 'Query - success' =
			
			CALCULATE (
			    [Queries],
			    Operation[StatusCode] = 0
			)
		formatString: #,0
		displayFolder: Count
		lineageTag: 00d1dbea-bb7f-4aea-b676-28ec0061104f

	measure 'Query - failure' =
			
			
			CALCULATE (
			    [Queries],
			    Operation[StatusCode] <> 0
			)
			
			// 0 = success, non-zero (usually negative) = failure
		formatString: #,0
		displayFolder: Count
		lineageTag: 5e5d5c3a-348e-4d3f-8a3f-b9dc1b34c958

	measure 'Query - success rate' =
			
			VAR successes = [Query - success]
			RETURN
			    DIVIDE (
			        successes,
			        successes + [Query - failure]
			    )
		formatString: 0%;-0%;0%
		displayFolder: Count
		lineageTag: bb7365aa-7b2a-4a56-b1fb-4e3f43972e7e

	measure 'Query - failure rate' =
			
			VAR failiures = [Query - failure]
			RETURN
			    DIVIDE (
			        failiures,
			        [Query - success] + failiures
			    )
		formatString: 0%;-0%;0%
		displayFolder: Count
		lineageTag: 194a32d6-9487-43ce-9ea8-d4292627c065

	measure 'Duration - Max' =
			
			MAX(Operation[Duration (ms)])
		formatString: #,0
		displayFolder: Duration - Operation
		lineageTag: 5aa8c59d-e2aa-4cfb-b43c-6b69c8820833

	measure 'Suboperations - Query' =
			
			COUNTROWS ( 'Suboperation - Query' )
		formatString: #,0
		displayFolder: Count
		lineageTag: 1786fc1c-f9bc-4d82-83cb-4af64396031b

	measure 'Suboperations - Query (card)' =
			
			-- This measure is intended for card visuals only so any blanks will show a "0" instead of "(Blank)"
			VAR _return = [Suboperations - Query]
			RETURN
			    IF (
			        ISBLANK ( _return ),
			        0,
			        _return
			    )
		formatString: #,0
		displayFolder: Count
		lineageTag: dd90cca7-4b70-4b83-987a-f747483bf329

	measure 'CPU Time (ms) Suboperation - Query' =
			
			SUM ( 'Suboperation - Query'[CpuTimeMs] )
		formatString: #,0
		displayFolder: CPU Time - Suboperation
		lineageTag: e8532c1f-7804-444c-a153-be139d4623ff

	measure 'Duration - Suboperation - Query' =
			
			SUM ( 'Suboperation - Query'[Duration (ms)] )
		formatString: #,0
		displayFolder: Duration - Suboperation
		lineageTag: 64e0ce89-2976-44ba-bb4c-7ce884e44625

	measure Workspace_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[Workspace] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[Workspace] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[Workspace] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[Workspace] )
			            && HASONEFILTER ( Operation[Workspace] ),
			        SELECTEDVALUE ( Operation[Workspace] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[Workspace] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[Workspace],
			                        ISFILTERED ( Operation[Workspace] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: 2aa1b96c-a932-4390-ba33-21365f7053b3

		changedProperty = DisplayFolder

	measure PremiumCapacity_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[PremiumCapacityId] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[PremiumCapacityId] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[PremiumCapacityId] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[PremiumCapacityId] )
			            && HASONEFILTER ( Operation[PremiumCapacityId] ),
			        SELECTEDVALUE ( Operation[PremiumCapacityId] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[PremiumCapacityId] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[PremiumCapacityId],
			                        ISFILTERED ( Operation[PremiumCapacityId] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: ca9b1315-7a9d-49a1-a825-5b9d8bcf3c50

		changedProperty = DisplayFolder

	measure DatasetMode_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[DatasetMode] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[DatasetMode] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[DatasetMode] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[DatasetMode] )
			            && HASONEFILTER ( Operation[DatasetMode] ),
			        SELECTEDVALUE ( Operation[DatasetMode] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[DatasetMode] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[DatasetMode],
			                        ISFILTERED ( Operation[DatasetMode] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: 7d7f35f1-5760-422e-87e9-79948da5ab0a

		changedProperty = DisplayFolder

	measure ReportId_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[ReportId] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[ReportId] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[ReportId] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[ReportId] )
			            && HASONEFILTER ( Operation[ReportId] ),
			        SELECTEDVALUE ( Operation[ReportId] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[ReportId] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[ReportId],
			                        ISFILTERED ( Operation[ReportId] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: 8be01d32-2d84-4e1e-a51b-58b693e1e449

		changedProperty = DisplayFolder

	measure User_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[Executing User] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW (  Operation[Executing User])
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL (  Operation[Executing User] )
			    )
			RETURN
			    IF (
			        ISFILTERED (  Operation[Executing User] )
			            && HASONEFILTER (  Operation[Executing User] ),
			        SELECTEDVALUE ( Operation[Executing User]),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA (  Operation[Executing User] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                         Operation[Executing User],
			                        ISFILTERED (  Operation[Executing User] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: bb528240-7a7c-468d-9a1e-f54a6056be27

		changedProperty = DisplayFolder

	measure Scenario_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[Scenario name] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[Scenario name] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[Scenario name] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[Scenario name] )
			            && HASONEFILTER ( Operation[Scenario name] ),
			        SELECTEDVALUE ( Operation[Scenario name] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[Scenario name] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[Scenario name],
			                        ISFILTERED ( Operation[Scenario name] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: b1726e48-df7c-4a92-b24d-405cbe7565e0

		changedProperty = IsHidden

		changedProperty = DisplayFolder

	measure Object_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( 'Suboperation - Refresh'[ObjectTable + ObjectName] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( 'Suboperation - Refresh'[ObjectTable + ObjectName] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( 'Suboperation - Refresh'[ObjectTable + ObjectName] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( 'Suboperation - Refresh'[ObjectTable + ObjectName] )
			            && HASONEFILTER ( 'Suboperation - Refresh'[ObjectTable + ObjectName] ),
			        SELECTEDVALUE ( 'Suboperation - Refresh'[ObjectTable + ObjectName] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( 'Suboperation - Refresh'[ObjectTable + ObjectName] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        'Suboperation - Refresh'[ObjectTable + ObjectName],
			                        ISFILTERED ( 'Suboperation - Refresh'[ObjectTable + ObjectName] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: 789f96fa-eb1e-4b6a-b82c-4cab21587813

		changedProperty = DisplayFolder

	measure Detail_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( 'Suboperation - Refresh'[Operation Detail] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( 'Suboperation - Refresh'[Operation Detail] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( 'Suboperation - Refresh'[Operation Detail] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( 'Suboperation - Refresh'[Operation Detail] )
			            && HASONEFILTER ( 'Suboperation - Refresh'[Operation Detail] ),
			        SELECTEDVALUE ( 'Suboperation - Refresh'[Operation Detail] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( 'Suboperation - Refresh'[Operation Detail] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        'Suboperation - Refresh'[Operation Detail],
			                        ISFILTERED ( 'Suboperation - Refresh'[Operation Detail] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		displayFolder: Smart Narrative
		lineageTag: ff15b637-d107-40fd-8fbe-34326afdbfdd

		changedProperty = DisplayFolder

	measure 'Timeline Visualization Duration Per Column' = ```
			
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK (
			            Operation[Start Date/Time],
			            TRUE ()
			        ),
			        ALLSELECTED ( Operation )
			    ) //CONVERT(MIN(Operation[Start Date/Time]), DOUBLE) * 1000
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( Operation[End Date/Time] ),
			        ALLSELECTED ( Operation )
			    ) //CONVERT(MAX(Operation[End Date/Time]), DOUBLE) * 1000
			VAR _numberOfColumnsInMatrix =
			    CALCULATE (
			        COUNTROWS ( 'Timeline Visual Columns' ),
			        REMOVEFILTERS ()
			    ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE (
			        DATEDIFF (
			            RangeStart,
			            RangeEnd,
			            SECOND
			        ),
			        _numberOfColumnsInMatrix
			    )
			VAR DurationType =
			    SWITCH (
			        TRUE (),
			        TimeSliceSeconds <= 60,
			            FORMAT (
			                TimeSliceSeconds,
			                "#.## " & "Seconds"
			            ),
			        TimeSliceSeconds <= 3600
			            && TimeSliceSeconds > 60,
			            FORMAT (
			                TimeSliceSeconds / 60,
			                "#.## " & "Minutes"
			            ),
			        TimeSliceSeconds <= 7200
			            && TimeSliceSeconds > 3600,
			            FORMAT (
			                TimeSliceSeconds / 60 / 60,
			                "#.## " & "Hours"
			            ),
			        TimeSliceSeconds > 7200,
			            FORMAT (
			                TimeSliceSeconds / 60 / 60 / 24,
			                "#.## " & "Days"
			            )
			    )
			RETURN
			    DurationType
			```
		lineageTag: 6a1a1f6a-6251-4f8b-aa85-cf595aac80fc

	measure 'Timeline Visualization Value' = ```
			
			// This is the measure for the Value field of the timeline matrix. It takes the total duration (first start -> last end) in scope and divides it by the number of columns
			// in the matrix. That is the duration that each cell in the matrix represents. It then determies whether each cell should be painted (1 or 0) depending on whether the event's duration falls within the timeframe that the cell represents.
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK (
			            Operation[Start Date/Time],
			            TRUE ()
			        ),
			        ALLEXCEPT (
			            Operation,
			            Operation[Start Date]
			        )
			    )
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( Operation[End Date/Time] ),
			        ALLEXCEPT (
			            Operation,
			            Operation[Start Date]
			        )
			    )
			VAR _numberOfColumnsInMatrix =
			    CALCULATE (
			        COUNTROWS ( 'Timeline Visual Columns' ),
			        REMOVEFILTERS ()
			    ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE (
			        DATEDIFF (
			            RangeStart,
			            RangeEnd,
			            SECOND
			        ),
			        _numberOfColumnsInMatrix
			    )
			VAR CurrentSlice =
			    MAX ( 'Timeline Visual Columns'[Time Slice] )
			VAR CurrentColumnMin = RangeStart + ( CurrentSlice - 1 ) * TimeSliceSeconds / ( 60 * 60 * 24 )
			VAR CurrentColumnMax = RangeStart + CurrentSlice * TimeSliceSeconds / ( 60 * 60 * 24 )
			RETURN
			    IF (
			        AND (
			            MIN ( Operation[Start Date/Time] ) >= CurrentColumnMin,
			            MIN ( Operation[End Date/Time] ) <= CurrentColumnMax
			        ),
			        1,
			        0
			    )
			
			```
		formatString: 0
		lineageTag: beba0ade-499e-4dc8-aa83-50233b16ef2a

	measure 'Timeline Visualization Duration Per Col' = ```
			
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK (
			            'Suboperation - Refresh'[Start Date/Time],
			            TRUE ()
			        ),
			        ALLSELECTED ( 'Suboperation - Refresh' )
			    ) //CONVERT(MIN('Suboperation - Refresh'[Start Date/Time]), DOUBLE) * 1000
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( 'Suboperation - Refresh'[End Date/Time] ),
			        ALLSELECTED ( 'Suboperation - Refresh' )
			    ) //CONVERT(MAX('Suboperation - Refresh'[End Date/Time]), DOUBLE) * 1000
			VAR _numberOfColumnsInMatrix =
			    CALCULATE (
			        COUNTROWS ( 'Timeline Visual Columns' ),
			        REMOVEFILTERS ()
			    ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE (
			        DATEDIFF (
			            RangeStart,
			            RangeEnd,
			            SECOND
			        ),
			        _numberOfColumnsInMatrix
			    )
			VAR DurationType =
			    SWITCH (
			        TRUE (),
			        TimeSliceSeconds <= 0,
			            FORMAT (
			                TimeSliceSeconds,
			                "#.### " & "miliSeconds"
			            ),
			        TimeSliceSeconds <= 60
			            && TimeSliceSeconds > 0,
			            FORMAT (
			                TimeSliceSeconds,
			                "#.### " & "Seconds"
			            ),
			        TimeSliceSeconds <= 3600
			            && TimeSliceSeconds > 60,
			            FORMAT (
			                TimeSliceSeconds / 60,
			                "#.### " & "Minutes"
			            ),
			        TimeSliceSeconds <= 7200
			            && TimeSliceSeconds > 3600,
			            FORMAT (
			                TimeSliceSeconds / 60 / 60,
			                "#.### " & "Hours"
			            ),
			        TimeSliceSeconds > 7200,
			            FORMAT (
			                TimeSliceSeconds / 60 / 60 / 24,
			                "#.## " & "Days"
			            )
			    )
			RETURN
			    DurationType
			```
		lineageTag: c02ef1f0-1c64-4c13-98a8-5bfcafdd2a7a

	measure 'Timeline Visualization Val' = ```
			
			// This is the measure for the Value field of the timeline matrix. It takes the total duration (first start -> last end) in scope and divides it by the number of columns
			// in the matrix. That is the duration that each cell in the matrix represents. It then determies whether each cell should be painted (1 or 0) depending on whether the event's duration falls within the timeframe that the cell represents.
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK (
			            'Suboperation - Refresh'[Start Date/Time],
			            TRUE ()
			        ),
			        ALLSELECTED ( 'Suboperation - Refresh' )
			    )
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( 'Suboperation - Refresh'[End Date/Time] ),
			        ALLSELECTED ( 'Suboperation - Refresh' )
			    )
			VAR _numberOfColumnsInMatrix =
			    CALCULATE (
			        COUNTROWS ( 'Timeline Visual Columns' ),
			        REMOVEFILTERS ()
			    ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE (
			        DATEDIFF (
			            RangeStart,
			            RangeEnd,
			            SECOND
			        ),
			        _numberOfColumnsInMatrix
			    )
			VAR CurrentSlice =
			    MAX ( 'Timeline Visual Columns'[Time Slice] )
			VAR CurrentColumnMin = RangeStart + ( CurrentSlice - 1 ) * TimeSliceSeconds / ( 60 * 60 * 24 )
			VAR CurrentColumnMax = RangeStart + CurrentSlice * TimeSliceSeconds / ( 60 * 60 * 24 )
			RETURN
			    IF (
			        AND (
			            MIN ( 'Suboperation - Refresh'[Start Date/Time] ) <= CurrentColumnMax,
			            MIN ( 'Suboperation - Refresh'[End Date/Time] ) >= CurrentColumnMin
			        ),
			        1,
			        0
			    )
			```
		formatString: 0
		lineageTag: 5eab81ed-2e75-4300-b826-296c30fc3db5

	measure DurationWithAgg =
			
			CALCULATE (
			    SUM ( 'Operation'[Duration (ms)] ),
			    'Operation'[IsAggregationUsed] == "Yes"
			)
		formatString: 0
		displayFolder: Duration - Operation
		lineageTag: 4691cbef-9107-4c9b-aed4-49009bd267d6

		changedProperty = DisplayFolder

	measure DurationY =
			
			CALCULATE (
			    SUM ( Operation[Duration (ms)] ),
			    Operation[IsAggregationUsed] = "Yes"
			)
		formatString: 0
		lineageTag: 1a0363d4-b699-494e-9996-25e00be6dc72

	measure DurationN =
			
			CALCULATE (
			    SUM ( Operation[Duration (ms)] ),
			    Operation[IsAggregationUsed] = "No"
			)
		formatString: 0
		lineageTag: 9c6c54a8-b01e-473d-ac39-9f0a23f9e022

	measure CPUTimeY =
			
			CALCULATE (
			    SUM ( Operation[CPUTime (ms)] ),
			    Operation[IsAggregationUsed] = "Yes"
			)
		formatString: 0
		lineageTag: 93457fc7-9ac2-46c4-8582-3fec1b94acf7

	measure CPUTimeN =
			
			CALCULATE (
			    SUM ( Operation[CPUTime (ms)] ),
			    Operation[IsAggregationUsed] = "No"
			)
		formatString: 0
		lineageTag: 29ca706c-7fc0-47b8-8b4c-47d97c27f039

	measure AggregationHit% =
			
			VAR percentage= CALCULATE (
			                            COUNT ( Operation[XmlaRequestId] ),Operation[IsAggregationUsed] = "Yes")
			                / COUNT ( Operation[XmlaRequestId] )
			return
			IF(percentage>0,percentage,0)
		formatString: 0.00%;-0.00%;0.00%
		lineageTag: 21130961-c4e4-4e3d-8b47-c707923de958

		changedProperty = FormatString

	measure CPUTimeWithAgg =
			
			CALCULATE (
			    SUM ( 'Operation'[CPUTime (ms)] ),
			    Operation[IsAggregationUsed] = "Yes"
			)
		formatString: 0
		displayFolder: CPU Time - Operation
		lineageTag: f5a0eabb-d5cf-49c0-b46e-c7dd792ab61e

		changedProperty = DisplayFolder

	measure 'Gantt value' =
			
			VAR MinCalendar = MIN('Calendar'[Date])
			VAR MaxCalendar = MAX('Calendar'[Date])+1
			RETURN
			IF( (
			MIN(Operation[Start Date/Time]) >= MinCalendar && MAX(Operation[Start Date/Time]) < MaxCalendar),[Timeline Visualization Value],BLANK())
		formatString: 0
		lineageTag: 22a4487b-9ff4-42c3-868b-2cb6b8b28c1c

	measure 'Weekly active users' =
			
			CALCULATE([User count], DATESINPERIOD('Calendar'[Date], max('Calendar'[Date]), -30, DAY)) +0
		formatString: 0
		displayFolder: Count
		lineageTag: 332bd3f3-7175-4d31-9d9c-3f6a844a9ada

	measure 'Gantt timeline refreshes' = ```
			
			// This is the measure for the Value field of the timeline matrix. It takes the total duration (first start -> last end) in scope and divides it by the number of columns
			// in the matrix. That is the duration that each cell in the matrix represents. It then determies whether each cell should be painted (1 or 0) depending on whether the event's duration falls within the timeframe that the cell represents.
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK ( Operation[Start Date/Time], TRUE () ),
			        ALLEXCEPT ( Operation, Operation[Start Date] )
			    )
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( Operation[End Date/Time] ),
			        ALLEXCEPT ( Operation, Operation[Start Date] )
			    )
			VAR _numberOfColumnsInMatrix =100
			    //CALCULATE ( COUNTROWS ( 'Timeline Visual Columns' ), REMOVEFILTERS () ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE ( DATEDIFF ( RangeStart, RangeEnd, SECOND ), _numberOfColumnsInMatrix )
			VAR CurrentSlice =
			    MAX ( 'Timeline Visual Columns'[Time Slice] )
			VAR CurrentColumnMin = RangeStart + ( CurrentSlice - 1 ) * TimeSliceSeconds / (86400 )
			VAR CurrentColumnMax = RangeStart + CurrentSlice * TimeSliceSeconds / ( 86400 )
			VAR Table1 =
			    CALCULATE (
			        COUNTROWS ( Operation ),
			        Operation[Start Date/Time] <= CurrentColumnMax,
			        Operation[End Date/Time] >= CurrentColumnMin
			    )
			RETURN
			    IF ( ISBLANK ( Table1 ), 0, Table1 )
			```
		formatString: 0
		lineageTag: ba52c0be-7d45-430e-aa81-c63cdb9178e2

	measure 'Date Interval' =
			
			FORMAT (
			    CALCULATE (
			        INT (
			            DATEDIFF (
			                MIN ( 'Calendar'[Date (no year)] ),
			                'Report Measures'[Date Mid Interval],
			                DAY
			            ) / 2
			        )
			            + MIN ( 'Calendar'[Date (no year)] )
			    ),
			    "dd mmm"
			)
		lineageTag: f603397a-a3cc-4596-adf8-2af8755bb263

	measure 'Date Mid Interval' =
			
			FORMAT (
			    CALCULATE (
			        DATEDIFF (
			            MIN ( 'Calendar'[Date (no year)] ),
			            MAX ( 'Calendar'[Date (no year)] ),
			            DAY
			        ) / 2
			            + MIN ( 'Calendar'[Date (no year)] )
			    ),
			    "dd mmm"
			)
		lineageTag: 2faa4162-d78e-44c6-acee-c33163713b96

	measure 'Date Interval 3' =
			
			FORMAT (
			    CALCULATE (
			        INT (
			            DATEDIFF (
			                'Report Measures'[Date Mid Interval],
			                MAX ( 'Calendar'[Date (no year)] ),
			                DAY
			            ) / 2
			        ) + 'Report Measures'[Date Mid Interval]
			    ),
			    "dd mmm"
			)
		lineageTag: 44e9217f-33f4-47f6-bce1-899ecd9956e1

	measure 'Duration (minutes)' = INT(DIVIDE([Duration (ms)], 60000))
		formatString: 0
		lineageTag: 9c84ecb8-b0e8-432c-92d9-d28a21dc3ce5

	measure 'Gantt timeline refreshes detail' = ```
			
			// This is the measure for the Value field of the timeline matrix. It takes the total duration (first start -> last end) in scope and divides it by the number of columns
			// in the matrix. That is the duration that each cell in the matrix represents. It then determies whether each cell should be painted (1 or 0) depending on whether the event's duration falls within the timeframe that the cell represents.
			VAR RangeStart =
			    CALCULATE (
			        FIRSTNONBLANK ( 'Suboperation - Refresh'[Start Date/Time], TRUE () ),
			        // ALLSELECTED ( 'Suboperation - Refresh' )
			        ALLEXCEPT( 'Suboperation - Refresh', 'Suboperation - Refresh'[Start Date], 'Suboperation - Refresh'[XmlaRequestId],Operation[XmlaRequestId])
			    )
			VAR RangeEnd =
			    CALCULATE (
			        MAX ( 'Suboperation - Refresh'[End Date/Time] ),
			        // ALLSELECTED ( 'Suboperation - Refresh' )
			        ALLEXCEPT( 'Suboperation - Refresh', 'Suboperation - Refresh'[Start Date], 'Suboperation - Refresh'[XmlaRequestId],Operation[XmlaRequestId])
			    )
			VAR _numberOfColumnsInMatrix =100
			    //CALCULATE ( COUNTROWS ( 'Timeline Visual Columns' ), REMOVEFILTERS () ) // How many columns will the matrix visual have? 
			VAR TimeSliceSeconds =
			    DIVIDE ( DATEDIFF ( RangeStart, RangeEnd, SECOND ), _numberOfColumnsInMatrix )
			VAR CurrentSlice =
			    MAX ( 'Timeline Visual Columns'[Time Slice] )
			VAR CurrentColumnMin = RangeStart + ( CurrentSlice - 1 ) * TimeSliceSeconds / ( 86400 )
			VAR CurrentColumnMax = RangeStart + CurrentSlice * TimeSliceSeconds / ( 86400)
			VAR Table1 =
			    CALCULATE (
			        COUNTROWS ( 'Suboperation - Refresh' ),
			        'Suboperation - Refresh'[Start Date/Time] <= CurrentColumnMax,
			        'Suboperation - Refresh'[End Date/Time] >= CurrentColumnMin
			    )
			RETURN
			    IF ( ISBLANK ( Table1 ), BLANK(), Table1 )
			```
		formatString: 0
		lineageTag: 8dc99a9a-4936-4c6a-b0d5-c62906351289

	measure 'Avg CPU Time - Query' = ```
			
			//RR (20240111) - QueryEnd is a CPU is a total and Vertipaq CPU is included no need to sum both.
			VAR QueryEndSum =
			    CALCULATE (
			        AVERAGE( 'Operation'[CPUTime (ms)] ),
			        'Operation'[Operation] = "QueryEnd"
			    )
			
			RETURN QueryEndSum
			// For DAX QueryEnds, CPU Time is calculated by adding the CPU Time of all VertiPaqSEQueryEnd suboperations to the CPU Time of the QueryEnd operation.
			// For DirectQuery queries, CPU Time is simply the QueryEnd CPU Time.
			// VAR QueryEndSum =
			//     CALCULATE (
			//         AVERAGE( 'Operation'[CPUTime (ms)] ),
			//         'Operation'[Operation] = "QueryEnd"
			//     )
			// VAR isDQ =
			//     CALCULATE (
			//         COUNTROWS (
			//             VALUES ( 'Suboperation - Refresh'[Operation Detail] )
			//         ),
			//         'Suboperation - Refresh'[Operation Detail] = "VertiPaqSEQueryEnd"
			//     )
			// VAR CPUTimeSE = 
			// // Storage Engine
			// // https://github.com/DaxStudio/DaxStudio/blob/3cf6ef12dae03dcd06369e4248774068359fee7b/src/DaxStudio.UI/ViewModels/ServerTimesViewModel.cs#L287
			// CALCULATE(
			//         AVERAGE( 'Suboperation - Query'[CpuTimeMs] ),
			//         'Suboperation - Query'[Operation] IN ({"VertiPaqSEQueryEnd", "DirectQueryEnd"})
			// )
			// RETURN
			//     IF (
			//         isDQ,
			//         QueryEndSum,
			//         QueryEndSum + CPUTimeSE
			//     )
			
			```
		displayFolder: CPU Time - Operation
		lineageTag: faba84f4-5e20-496e-94a3-56ce80a2842a

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Query Detail. Queries' =
			
			"Query details ("
			    & FORMAT (
			        [Queries],
			        "#,##0"
			    ) & ")"
		lineageTag: 1b86f2c6-3206-489a-83bf-6b784656756e

	measure 'CPU Time (s) Total' = DIVIDE([CPU Time (ms) Total],1000)
		formatString: 0.00
		displayFolder: Count
		lineageTag: b474226f-543f-4dbf-b7e9-c1f9511839e0

		changedProperty = FormatString

	measure 'Refresh - failure' =
			
			CALCULATE (
			    [Refreshes],
			    Operation[StatusCode] <> 0
			)
			
			// 0 = success, non-zero (usually negative) = failure
		formatString: 0
		displayFolder: Count
		lineageTag: 9978c8f2-f117-4cb9-903e-091593d6f47a

	measure 'Refresh - success' =
			
			CALCULATE (
			    [Refreshes],
			    Operation[StatusCode] = 0
			)
			// 0 = success, non-zero (usually negative) = failure
		formatString: 0
		displayFolder: Count
		lineageTag: 84e36d09-2790-43df-a3fb-0cc5cc4ef931

	measure 'Refresh - failure rate' =
			
			VAR failiures = [Refresh - failure]
			RETURN
			    DIVIDE (
			        failiures,
			        [Refresh - success] + failiures
			    )
		displayFolder: Count
		lineageTag: 6b10e6cc-dc57-4db6-bc26-39dfb8040f35

		annotation PBI_FormatHint = {"isGeneralNumber":true}

	measure 'Query failure(card)' = [Query - failure]+0
		formatString: 0
		displayFolder: Count
		lineageTag: cd9a6f10-a8fb-41b7-8c91-ed034b53256c

	measure Reason = CALCULATE(MIN(Operation[EventText]),Operation[Operation]="Error",ALL(Operation[EventText]))
		lineageTag: a76e9308-62b1-4a57-a731-9b0d8811c60e

	measure 'Refresh failure(card)' = [Refresh - failure]+0
		formatString: 0
		displayFolder: Count
		lineageTag: ce8f428f-861f-4b67-aeb4-8ac39b43f530

	measure 'Total Error' = CALCULATE(COUNTROWS(Operation),Operation[Status] == "Failed",Operation[Operation]<>"Error")
		formatString: 0
		displayFolder: Count
		lineageTag: 29bb23ec-bc86-4144-b2d1-0d9f1ead16a1

	measure 'Total query duration' = [Queries] * [Duration (ms)]
		formatString: 0
		lineageTag: caada502-fb6c-4cfc-912a-6966edf3f9f9

	measure 'User count (card)' =
			
			DISTINCTCOUNT (Operation[Executing User] )+0
		formatString: 0
		lineageTag: d2f10707-f6c7-47b2-9743-c67e01b186d1

	measure TopN_ReportTitle = "Top " & SELECTEDVALUE ( 'Top N Selector'[SelectorSort] ) & " reports with high CPU usage"
		lineageTag: 0a71a689-ad01-45c6-bc0e-1f0a9f91e515

	measure TopN_UserTitle = "Top " & SELECTEDVALUE ( 'Top N Selector'[SelectorSort] ) & " users with high CPU usage"
		lineageTag: f07b0271-4e8a-4cb6-a963-99e65659ddc0

	measure TopN_OperationsTitle = "Top " & SELECTEDVALUE ( 'Top N Selector'[SelectorSort] ) & " users by operation"
		lineageTag: 22c4231f-cf80-43b1-b2fe-97d01c73db99

	measure TopN_QueriesTitle = "Top " & SELECTEDVALUE ( 'Top N Selector'[SelectorSort] ) & " users by query execution"
		lineageTag: 51a05d17-9e9b-47c6-b1a6-4b9dcb5e9839

	measure Dataset_multiple =
			
			VAR selectedrows =
			    COUNTROWS (
			        ALLSELECTED ( Operation[Dataset] )
			    )
			VAR noblankrows =
			    COUNTROWS (
			        ALLNOBLANKROW ( Operation[Dataset] )
			    )
			VAR allrows =
			    COUNTROWS (
			        ALL ( Operation[Dataset] )
			    )
			RETURN
			    IF (
			        ISFILTERED ( Operation[Dataset] )
			            && HASONEFILTER ( Operation[Dataset] ),
			        SELECTEDVALUE ( Operation[Dataset] ),
			        IF (
			            OR (
			                selectedrows == noblankrows,
			                selectedrows == allrows
			            ),
			            "All",
			            IF (
			                COUNTA ( Operation[Dataset] ) > 1,
			                CONCATENATE (
			                    FIRSTNONBLANK (
			                        Operation[Dataset],
			                        ISFILTERED ( Operation[Dataset] )
			                    ),
			                    " & more"
			                ),
			                "All"
			            )
			        )
			    )
		lineageTag: b6d4d458-95c3-4ea0-9c1c-97c854e249af

	partition 'Report Measures-740adfb2-5ab6-4f52-a806-24f38d21026f' = m
		mode: import
		source =
				let
				    Source = Table.FromRows(Json.Document(Binary.Decompress(Binary.FromText("i44FAA==", BinaryEncoding.Base64), Compression.Deflate)), let _t = ((type nullable text) meta [Serialized.Text = true]) in type table [Column1 = _t]),
				    #"Changed Type" = Table.TransformColumnTypes(Source,{{"Column1", type text}}),
				    #"Removed Columns" = Table.RemoveColumns(#"Changed Type",{"Column1"})
				in
				    #"Removed Columns"

	annotation PBI_ResultType = Table

